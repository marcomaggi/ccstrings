\input texinfo.tex
@c %**start of header
@setfilename ccstrings.info
@settitle CCStrings
@c %**end of header

@include version.texi
@include macros.texi
@include ccexceptions-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCStrings

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCStrings

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccstrings

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017-2020

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.10.0
@set CCMemoryVersion           0.3.0
@set CCStructsVersion          0.4.0
@set CCTestsVersion            0.5.0

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCSTRINGS
@set PackagePkgconfigModule             ccstrings
@set PackageLibsVar                     @env{CCSTRINGS_LIBS}
@set PackageCflagsVar                   @env{CCSTRINGS_CFLAGS}
@c This is the stem of the library in "libccstrings.so".
@set PackageLibstem                     ccstrings
@set PackageApiPrefixLower              ccstr_
@set PackageApiPrefixUpper              CCSTR_

@set PackageHeader                      ccstrings.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@c ------------------------------------------------------------

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing custom strings.

The library supports @posix{} platforms.  The library depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: the package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccstrings: (ccstrings).       CCStrings a template library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* init::                        Library initialisation.
* conditions::                  Condition objects.
* buffers::                     Collecting output in buffers.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing custom strings.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: this package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, but the whole @api{} is accessible by including
@value{PackageHeaderFile}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

We need to remember that, before using the library, we must call:

@example
ccstr_library_init();
@end example

@noindent
to initialise some internal data structures.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccstr_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccstr_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccstr_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccstr_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node init
@chapter Library initialisation


@deftypefun void ccstr_library_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node conditions
@chapter Condition objects


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_catch_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_body_handlers(L);
@}
@end example

@menu
* conditions size overflow::      Size overflow exceptional conditions.
* conditions incomplete output::  Incomplete output exceptional conditions.
@end menu

@c page
@node conditions size overflow
@section Size overflow exceptional conditions


@cindex Size overflow, exceptional condition
@cindex Exceptional conditions, size overflow


The @dfn{buffer size overflow} exceptional--condition object--type has the purpose of describing an
exceptional--condition caused by an attempt to allocate a buffer too big.


@CCEDescriptorTypedef{ccstr,buffer_size_overflow,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccstr,buffer_size_overflow}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccstr_buffer_t const * buffer
Pointer to the buffer.  The exceptional--condition object instance @strong{does not} own this
buffer: it responsibility of the user to delete the buffer when appropriate.

@item size_t required_len
The number of free bytes that were requested in the buffer.
@end table
@end deftp


@CCEConditionObjectNew{ccstr,buffer_size_overflow,{ccstr_buffer_t const * @var{B}, size_t @var{required_len}}}


@CCEConditionObjectPredicate{ccstr,buffer_size_overflow}


@CCEConditionSubtypingFacilitiesFailing{ccstr,buffer_size_overflow,{ccstr_buffer_t const * @var{B}, size_t @var{required_len}}}

@c page
@node conditions incomplete output
@section Incomplete output exceptional conditions


@cindex Incomplete output, exceptional condition
@cindex Exceptional conditions, incomplete output


The @dfn{buffer incomplete output} exceptional--condition object--type has the purpose of describing
an exceptional--condition caused by an attempt to write a buffer to an output device and only some
of the data is written.


@CCEDescriptorTypedef{ccstr,buffer_incomplete_output,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccstr,buffer_incomplete_output}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccstr_buffer_t const * buffer
Pointer to the buffer.

@item size_t written_len
The number of bytes that were written to the device.
@end table
@end deftp


@CCEConditionObjectNew{ccstr,buffer_incomplete_output,{ccstr_buffer_t const * @var{B}, size_t @var{written_len}}}


@CCEConditionObjectPredicate{ccstr,buffer_incomplete_output}


@CCEConditionSubtypingFacilitiesFailing{ccstr,buffer_incomplete_output,{ccstr_buffer_t const * @var{B}, size_t @var{written_len}}}

@c page
@node buffers
@chapter Collecting output in buffers


Programmatically generated textual output is gathered in @dfn{buffers}: dynamically allocated blocks
of memory that can be resized and to which we write with functions similar to the standard
@cfunc{vsnprintf}.  The definitions of the buffers @api{} are accessible in the header file
@file{ccstrings.h}.


@deftp {Struct Typedef} ccstr_buffer_t
Type of data structures representing output buffers.  Internally, this structure holds a pointer to
a block of memory holding the actual data; such memory is allocated with @cfunc{malloc}.
@end deftp


@menu
* buffers ctors::               Constructors and destructors.
* buffers format::              Formatting buffer contents.
* buffers output::              Writing output to buffers.
* buffers inspection::          Inspecting buffers.
* buffers memory::              Buffers memory handlers.
* buffers traits::              Implemented traits.
@end menu

@c page
@node buffers ctors
@section Constructors and destructors


@menu
* buffers ctors embedded::      Constructors and destructors for
                                embedded instances.
* buffers ctors standalone::    Constructors and destructors for
                                standalone instances.
* buffers ctors handlers::      Exception handlers.
@end menu

@c page
@node buffers ctors embedded
@subsection Constructors and destructors for embedded instances


@menu
* buffers ctors embedded plain::    Plain initialisation and finalisation.
* buffers ctors embedded guarded::  Guarded initialisation.
@end menu

@c page
@node buffers ctors embedded plain
@subsubsection Plain initialisation and finalisation


An @dfn{embedded instance} is a @struct{} instance allocated on the stack or embedded into another,
enclosing, @struct{} instance.  This section documents the @emph{plain} initialisation and
finalisation functions, which are the ones to use when embedding a buffer instance into an enclosing
@struct{} type; example:

@smallexample
typedef struct envelope_t       envelope_t;

struct envelope_t @{
  ccstr_buffer_t        B[1];
@};

void
ccname_init(envelope_t) (cce_destination_t upper_L, envelope_t * E)
@{
  cce_location_t        L[1];
  cce_error_handler_t   B_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    ccname_init(ccstr_buffer_t)(L, E->B, 64);
    ccstr_init_and_register_buffer_handler(L, B_H, E->B);

    /* Initialise the other fields of E, if any. */
    cce_run_body_handlers(L);
  @}
@}

void
ccname_final(envelope_t) (envelope_t * E)
@{
  ccname_final(ccstr_buffer_t)(E->B);
@}

void
ccname_init(envelope_t, clean) (cce_destination_t L,
   cce_clean_handler_t * E_H, envelope_t * E)
@{
  ccname_init(envelope_t)(L, E);
  cce_init_and_register_handler
    (L, E_H, cce_default_clean_handler_function,
     cce_resource_pointer(E),
     cce_resource_destructor(ccname_final(envelope_t)));
@}

void
ccname_init(envelope_t, error) (cce_destination_t L,
   cce_error_handler_t * E_H, envelope_t * E)
@{
  ccname_init(envelope_t)(L, E);
  cce_init_and_register_handler
    (L, E_H, cce_default_error_handler_function,
     cce_resource_pointer(E),
     cce_resource_destructor(ccname_final(envelope_t)));
@}
@end smallexample

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun void {ccname_init(ccstr_buffer_t)} (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, size_t @var{initial_buflen})
Initialise an already allocated buffer instance referenced by @var{B}.  Allocate memory for the
buffer with the initial size of @var{initial_buflen}.  If an error occurs allocating: perform a
non--local exit by jumping to @var{L}.

We can initialise an embedded instance, associating it to a clean handler, as follows; notice how
the buffer instance allocated on the stack must be outside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   B_H[1];
ccstr_buffer_t        B[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t)(L, B, 64);
  ccstr_init_and_register_buffer_handler(L, B_H, B);
  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun void {ccname_init(ccstr_buffer_t, copy)} (cce_destination_t @var{L}, ccstr_buffer_t * @var{dst}, ccstr_buffer_t const * @var{src})
Initialise an already allocated buffer instance referenced by @var{dst}.  Make a perfect copy of the
buffer referenced by @var{src}.  If an error occurs: perform a non--local exit by jumping to
@var{L}.

We can initialise a copy embedded instance, associating it to a clean handler, as follows; notice
how the buffer instance allocated on the stack must be outside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
ccstr_buffer_t        src[1], dst[1];
cce_clean_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t)(L, src, 64);
  ccstr_init_and_register_buffer_handler(L, src_H, src);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");

  ccname_init(ccstr_buffer_t, copy)(L, dst, src);
  ccstr_init_and_register_buffer_handler(L, dst_H, dst);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun void {ccname_final(ccstr_buffer_t)} (ccstr_buffer_t * @var{B})
Finalise the buffer instance referenced by @var{B}.  Release data memory allocated for the buffer.
Reset the structure fields.  The block of memory holding the structure itself is left untouched.
@end deftypefun

@c page
@node buffers ctors embedded guarded
@subsubsection Guarded initialisation


An @dfn{embedded instance} is @struct{} instance allocated on the stack or embedded into another,
enclosing, @struct{} instance.  This section documents the @emph{guarded} initialisation functions:
the buffer instances are associated to an exception handler that takes care of finalising them upon
exiting a location context, @ccexceptionsref{handlers, The location handlers @api{}}.  These
functions are the ones to use when we put the buffer instance on the stack for local use within the
dynamic extent of a function call.

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun void {ccname_init(ccstr_buffer_t, clean)} (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccstr_buffer_t * @var{B}, size_t @var{initial_buflen})
Initialise an already allocated buffer instance referenced by @var{B}.  Allocate memory for the
buffer with the initial size of @var{initial_buflen}.  Associate the buffer to the handler
referenced by @var{H} in the context of the location @var{L}.  If an error occurs allocating:
perform a non--local exit by jumping to @var{L}.

We can initialise and finalise an embedded instance using the guarded constructor with a clean
handler as follows; notice how the buffer instance allocated on the stack must be outside the
@code{if} location statement:

@smallexample
cce_location_t        L[1];
ccstr_buffer_t        B[1];
cce_clean_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t, clean)(L, B_H, B, 64);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun void {ccname_init(ccstr_buffer_t, error)} (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccstr_buffer_t * @var{B}, size_t @var{initial_buflen})
Initialise an already allocated buffer instance referenced by @var{B}.  Allocate memory for the
buffer with the initial size of @var{initial_buflen}.  Associate the buffer to the handler
referenced by @var{H} in the context of the location @var{L}.  If an error occurs allocating:
perform a non--local exit by jumping to @var{L}.

We can initialise and finalise an embedded instance using the guarded constructor with an error
handler as follows; notice how the buffer instance allocated on the stack must be outside the
@code{if} location statement:

@smallexample
cce_location_t        L[1];
ccstr_buffer_t        B[1];
cce_error_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t, error)(L, B_H, B, 64);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));

  /* This will not finalise the buffer! */
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun void {ccname_init(ccstr_buffer_t, copy, clean)} (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccstr_buffer_t * @var{dst}, ccstr_buffer_t const * @var{src})
Initialise an already allocated buffer instance referenced by @var{dst}.  Make a perfect copy of
the buffer referenced by @var{src}.  Associate the buffer to the handler referenced by @var{H} in
the context of the location @var{L}.  If an error occurs allocating: perform a non--local exit by
jumping to @var{L}.

We can initialise and finalise an embedded instance using the guarded copy constructor with a clean
handler as follows; notice how the buffer instance allocated on the stack must be outside the
@code{if} location statement:

@smallexample
cce_location_t        L[1];
ccstr_buffer_t        src[1],   dst[1];
cce_clean_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t, clean)(L, src_H, src, 64);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");

  ccname_init(ccstr_buffer_t, copy, clean)(L, dst_H, dst, src);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun void {ccname_init(ccstr_buffer_t, copy, error)} (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccstr_buffer_t * @var{dst}, ccstr_buffer_t const * @var{src})
Initialise an already allocated buffer instance referenced by @var{dst}.  Make a perfect copy of the
buffer referenced by @var{src}.  Associate the buffer to the handler referenced by @var{H} in the
context of the location @var{L}.  If an error occurs allocating: perform a non--local exit by
jumping to @var{L}.

We can initialise and finalise an embedded instance using the guarded copy constructor with a error
handler as follows; notice how the buffer instance allocated on the stack must be outside the
@code{if} location statement:

@smallexample
cce_location_t        L[1];
ccstr_buffer_t        src[1],   dst[1];
cce_error_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccname_init(ccstr_buffer_t, error)(L, src_H, src, 64);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");

  ccname_init(ccstr_buffer_t, copy, error)(L, dst_H, dst, src);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));

  /* This will not finalise the buffers! */
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun

@c page
@node buffers ctors standalone
@subsection Constructors and destructors for standalone instances


@menu
* buffers ctors standalone plain::    Plain constructors and destructors.
* buffers ctors standalone guarded::  Guarded constructors.
@end menu

@c page
@node buffers ctors standalone plain
@subsubsection Plain constructors and destructors


A @dfn{standalone instance} is @struct{} instance dynamically allocated on the heap.  This section
documents the @emph{plain} constructor and destructor functions; it is normally better to use the
guarded constructors, @ref{buffers ctors standalone guarded, Guarded constructors}.

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t)} (cce_destination_t @var{L}, size_t @var{initial_buflen})
Build a new instance and return a pointer to it.  Allocate memory for the buffer with the initial
size of @var{initial_buflen}.  If an error occurs allocating: perform a non--local exit by jumping
to @var{L}.

We can construct a standalone instance using the plain constructor, associating it to a clean
handler, as follows; notice how the pointer to buffer instance allocated on the heap can be inside
the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t      *B = ccname_new(ccstr_buffer_t)(L, 64);
  ccstr_init_and_register_buffer_handler(L, B_H, B);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t, copy)} (cce_destination_t @var{L}, ccstr_buffer_t const * @var{src})
Build a new instance and return a pointer to it.  Make a perfect copy of the buffer referenced by
@var{src}.  If an error occurs: perform a non--local exit by jumping to @var{L}.

We can construct a standalone instance using the plain copy constructor, associating it to a clean
handler, as follows; notice how the pointer to buffer instance allocated on the heap can be inside
the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t      *src, *dst;

  src = ccname_new(ccstr_buffer_t)(L, 64);
  ccstr_init_and_register_buffer_handler(L, src_H, src);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");

  dst = ccname_new(ccstr_buffer_t, copy)(L, src);
  ccstr_init_and_register_buffer_handler(L, dst_H, dst);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun

@c page
@node buffers ctors standalone guarded
@subsubsection Guarded constructors


A @dfn{standalone instance} is @struct{} instance dynamically allocated on the heap.  This section
documents the @emph{guarded} constructor functions: the buffer instances are associated to an
exception handler that takes care of finalising them upon exiting a location context,
@ccexceptionsref{handlers, The location handlers @api{}}.

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t, clean)} (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, size_t @var{initial_buflen})
Build a new instance and return a pointer to it.  Allocate memory for the buffer with the initial
size of @var{initial_buflen}.  Associate the buffer to the handler referenced by @var{H} in the
context of the location @var{L}.  If an error occurs allocating: perform a non--local exit by
jumping to @var{L}.

We can construct a standalone instance using the guarded constructor as follows; notice how the
pointer to buffer instance allocated on the heap can be inside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t  *B = ccname_new(ccstr_buffer_t, clean)(L, B_H, 64);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t, error)} (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, size_t @var{initial_buflen})
Build a new instance and return a pointer to it.  Allocate memory for the buffer with the initial
size of @var{initial_buflen}.  Associate the buffer to the handler referenced by @var{H} in the
context of the location @var{L}.  If an error occurs allocating: perform a non--local exit by
jumping to @var{L}.

We can construct a standalone instance using the guarded constructor as follows; notice how the
pointer to buffer instance allocated on the heap can be inside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_error_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t  *B = ccname_new(ccstr_buffer_t, error)(L, B_H, 64);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));

  /* This will not destroy the buffer! */
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t, copy, clean)} (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccstr_buffer_t const * @var{src})
Build a new instance and return a pointer to it.  Make a perfect copy of the buffer referenced by
@var{src}.  Associate the buffer to the handler referenced by @var{H} in the context of the location
@var{L}.  If an error occurs allocating: perform a non--local exit by jumping to @var{L}.

We can construct a standalone instance using the guarded copy constructor as follows; notice how the
pointer to buffer instance allocated on the heap can be inside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t      *src, *dst;

  src = ccname_new(ccstr_buffer_t, clean)(L, src_H, 64);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");
  dst = ccname_new(ccstr_buffer_t, copy, clean)(L, dst_H, src);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun {ccstr_buffer_t *} {ccname_new(ccstr_buffer_t, copy, error)} (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccstr_buffer_t const * @var{src})
Build a new instance and return a pointer to it.  Make a perfect copy of the buffer referenced by
@var{src}.  Associate the buffer to the handler referenced by @var{H} in the context of the location
@var{L}.  If an error occurs allocating: perform a non--local exit by jumping to @var{L}.

We can construct a standalone instance using the guarded copy constructor as follows; notice how the
pointer to buffer instance allocated on the heap can be inside the @code{if} location statement:

@smallexample
cce_location_t        L[1];
cce_error_handler_t   src_H[1], dst_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t      *src, *dst;

  src = ccname_new(ccstr_buffer_t, error)(L, src_H, 64);
  ccstr_buffer_format(L, src, "These are the buffer's contents.\n");
  dst = ccname_new(ccstr_buffer_t, copy, error)(L, dst_H, src);

  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(src));
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(dst));

  /* This will not destroy the buffers! */
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun

@c page
@node buffers ctors handlers
@subsection Exception handlers


@menu
* buffers ctors handlers embedded::    Exception handlers for embedded
                                       buffer instances.
* buffers ctors handlers standalone::  Exception handlers for standalone
                                       buffer instances.
@end menu

@c page
@node buffers ctors handlers embedded
@subsubsection Exception handlers for embedded buffer instances


An @dfn{embedded instance} is a @struct{} instance allocated on the stack or embedded into another,
enclosing, @struct{} instance.  Exception handlers allow us to trigger finalisation of buffer
instances upon leaving a location context, @ccexceptionsref{handlers, The location handlers @api{}}.

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun void ccstr_init_and_register_final_buffer_clean_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.
@end deftypefun


@deftypefun void ccstr_init_and_register_final_buffer_error_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccstr_init_and_register_final_buffer_handler (cce_destination_t @var{L}, @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.  If the type of the pointer @var{H} is:

@table @code
@item cce_clean_handler_t *
The macro use expands into a call to @cfunc{ccstr_init_and_register_final_buffer_clean_handler}.

@item cce_error_handler_t *
The macro use expands into a call to @cfunc{ccstr_init_and_register_final_buffer_error_handler}.
@end table
@end deftypefn

@c page
@node buffers ctors handlers standalone
@subsubsection Exception handlers for standalone buffer instances


A @dfn{standalone instance} is @struct{} instance dynamically allocated on the heap.  Exception
handlers allow us to trigger deleteisation of buffer instances upon leaving a location context,
@ccexceptionsref{handlers, The location handlers @api{}}.

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun void ccstr_init_and_register_delete_buffer_clean_handler (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.
@end deftypefun


@deftypefun void ccstr_init_and_register_delete_buffer_error_handler (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccstr_init_and_register_delete_buffer_handler (cce_destination_t @var{L}, @var{H}, ccstr_buffer_t const * @var{B})
Associate the buffer referenced by @var{B} to the handler referenced by @var{H} in the context of
the location @var{L}.  If the type of the pointer @var{H} is:

@table @code
@item cce_clean_handler_t *
The macro use expands into a call to @cfunc{ccstr_init_and_register_delete_buffer_clean_handler}.

@item cce_error_handler_t *
The macro use expands into a call to @cfunc{ccstr_init_and_register_delete_buffer_error_handler}.
@end table
@end deftypefn

@c page
@node buffers format
@section Formatting buffer contents


To format an @ascii{} string into a buffer, we do:

@example
cce_location_t          L[1];
ccstr_buffer_t          B[1];
cce_clean_handler_t     B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccname_init(ccstr_buffer_t)(L, B_H, B, 64);

  ccstr_buffer_format(L, "number=%d", 123);
  cce_run_body_handlers(L);
@}
@end example

The following definitions are accessible in the header file @file{ccstrings.h}.


@deftypefun void ccstr_buffer_format (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, char const * @var{template}, @dots{})
Format a string and append it to the buffer.  If there is not enough free room in the buffer:
reallocate it enlarging the size.  If an error occurs reallocating: perform a non--local exit by
jumping to @var{L}; in this case @var{B} is left untouched and its contents are still valid.

The buffer is formatted according to @var{template} and the given optional arguments.  The supported
format is the same of the standard @cfunc{printf}.
@end deftypefun


@deftypefun void ccstr_buffer_vformat (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, char const * @var{template}, va_list @var{ap})
Like @cfunc{ccstr_buffer_format}, but reads arguments from @var{ap}.  Internally @var{ap} is
duplicated, so externally it is left untouched.  We can use this function as follows:

@example
void
print (cce_destination_t L, ccstr_buffer_t * B,
       char const * template, ...)
@{
  va_list       ap;

  va_start(ap, template);
  @{
    ccstr_buffer_vformat(L, B, "X=%g\n", ap);
  @}
  va_end(ap);
@}
@end example
@end deftypefun

@c page
@node buffers output
@section Writing output to buffers


@deftypefun void ccstr_buffer_fwrite (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, FILE * @var{stream})
Write the buffer contents to @var{stream}, using the system call @cfunc{fwrite}.  If an error
occurs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void ccstr_buffer_write (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, int @var{filedes})
Write the buffer contents to @var{filedes}, using the system call @cfunc{write}.

@itemize
@item
If the system call completes successfully and all the data is written: return.

@item
If the system call completes successfully but not all the data is written: raise an exception by
performing a non--local exit to @var{L}.

@item
If an error occurs and @code{errno} is set to @code{EINTR}: the function loops internally trying
again to write data.

@item
If an error occurs: raise an exception by performing a non--local exit to @var{L}.
@end itemize
@end deftypefun

@c page
@node buffers inspection
@section Inspecting buffers


@deftypefun bool ccstr_buffer_is_full (ccstr_buffer_t * @var{B})
Return @ctrue{} if the buffer is full; otherwise return @cfalse{}.
@end deftypefun


@deftypefun ccmem_block_t ccstr_buffer_output_block (ccstr_buffer_t * @var{B})
@deftypefunx ccmem_ascii_t ccstr_buffer_output_ascii (ccstr_buffer_t * @var{B})
Return a block representing the data in the buffer.  If @var{B} references an initialised buffer:
the pointer in the block is never @cnull{}.
@end deftypefun


@deftypefun ccmem_block_t ccstr_buffer_target_block (ccstr_buffer_t * @var{B})
@deftypefunx ccmem_ascii_t ccstr_buffer_target_ascii (ccstr_buffer_t * @var{B})
Return a block representing the free room at the end of the buffer.  If @var{B} references an
initialised buffer: the pointer in the block is never @cnull{}.  The return value of this function
is meaningful only if a call to @cfunc{ccstr_buffer_is_full} applied to the same buffer returns
@cfalse{}.
@end deftypefun

@c page
@node buffers memory
@section Buffers memory handlers


@deftypefun void ccstr_buffer_enlarge (cce_destination_t @var{L}, ccstr_buffer_t * @var{B}, size_t @var{required_len})
Reallocate the buffer enlarging it so that it can hold more than @var{required_len} characters.  If
an error occurs reallocating: perform a non--local exit by jumping to @var{L}; in this case the
buffer is left untouched and its contents are still valid.
@end deftypefun

@c page
@node buffers traits
@section Implemented traits


@value{PACKAGE} implements some traits for the @struct{} type @objtype{ccstr_buffer_t}; the core
traits are defined by the package CCStructs, @ccstructsref{Top, CCStructs}.


@deftypefun ccstructs_dtor_T {ccname_trait_new(ccstructs_dtor_T, ccstr_buffer_t, embedded)} (ccstr_buffer_t const * @var{B})
Constructor for a @objtype{ccstructs_dtor_T} trait that destroys an embedded buffer instance,
@ccstructsref{dtor, The @trait{dtor} trait}.  We can use it as follows:

@smallexample
cce_location_t                L[1];
ccstr_buffer_t                B[1];
ccstructs_clean_handler_t     B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstructs_dtor_T    DB;

  ccname_init(ccstr_buffer_t)(L, B, 64);
  DB = ccname_trait_new(ccstructs_dtor_T, ccstr_buffer_t, embedded)(B);
  ccstructs_init_and_register_handler(L, B_H, DB);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun ccstructs_dtor_T {ccname_trait_new(ccstructs_dtor_T, ccstr_buffer_t, standalone)} (ccstr_buffer_t const * @var{B})
Constructor for a @objtype{ccstructs_dtor_T} trait that destroys a standalone buffer instance,
@ccstructsref{dtor, The @trait{dtor} trait}.  We can use it as follows:

@smallexample
cce_location_t                L[1];
ccstructs_clean_handler_t     B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t      *B;
  ccstructs_dtor_T    DB;

  B  = ccname_new(ccstr_buffer_t)(L, 64);
  DB = ccname_trait_new(ccstructs_dtor_T, ccstr_buffer_t, standalone)(B);
  ccstructs_init_and_register_handler(L, B_H, DB);

  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");
  ccstructs_dumpable_dump
    (L, ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B));
  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun


@deftypefun ccstructs_dumpable_T {ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)} (ccstr_buffer_t const * @var{B})
Constructor for a @objtype{ccstructs_dumpable_T} trait that prints a struct representation on
@stderr{}, @ccstructsref{dumpable, The @trait{dumpable} trait}.  We can use it as follows:

@smallexample
cce_location_t        L[1];
cce_clean_handler_t   B_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccstr_buffer_t        *B;
  ccstructs_dumpable_T   DB;

  B = ccname_new(ccstr_buffer_t, clean)(L, B_H, 64);
  ccstr_buffer_format(L, B, "These are the buffer's contents.\n");

  DB = ccname_trait_new(ccstructs_dumpable_T, ccstr_buffer_t)(B);
  ccstructs_dumpable_dump(L, DB);

  cce_run_body_handlers(L);
@}
@end smallexample
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can find the package CCExceptions at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

